# 协议文档

- MQTT V3.3.1  
  中文文档 https://www.zybuluo.com/khan-lau/note/1326839  
  
- MQTT V5.0  
  中文文档 https://www.zybuluo.com/khan-lau/note/1325300  
  V5.0 新特性 https://zhuanlan.zhihu.com/p/37121056  



 ### 第二次总结


服务质量为了满足不同的场景，MQTT支持三种不同级别的服务质量（Quality of Service，QoS）为不同场景提供消息可靠性：  
  
•	级别0：尽力而为。消息发送者会想尽办法发送消息，但是遇到意外并不会重试。  
  
•	级别1：至少一次。消息接收者如果没有知会或者知会本身丢失，消息发送者会再次发送以保证消息接收者至少会收到一次，当然可能造成重复消息。
  
•	级别2：恰好一次。保证这种语义肯定会减少并发或者增加延时，不过丢失或者重复消息是不可接受的时候，级别2是最合适的。  

根据以上  
  
当MQTT环境为如下时：  应用消息分发的服务质量(QoS)为 1，即至少分发一次；  
  
保留消息处理属性为0, 即服务端必须发送主题与客户端订阅的主题过滤器相匹配的所有保留消息；   
  
假设此时已经有一台不正常设备（客户端）被入侵者控制，该设备向 Broker 发送的含有经过恶意设置的PUBLISH报文的保留(Retain)标志被设置为1, 则 Broker 服务端必须存储此经过恶意设置的应用消息, 并用其替换此话题下任何已存在的消息。  
然后订阅此主题其他合法的设备会收到此消息，由于攻击者的恶意设置，该合法设备收到此消息后不会发出PUBACK消息（不做回应或为断开连接）。而服务端期待其做出回应，由于得不到回应，便会在一段时间内用大量消息轰炸该合法设备，造成对合法设备的 DOS 攻击。

#### 以上来源：https://www.zybuluo.com/khan-lau/note/1325300#432-qos-1%E8%87%B3%E5%B0%91%E5%88%86%E5%8F%91%E4%B8%80%E6%AC%A1  

MQTT是基于消息实现了发布者-订阅者模式的协议，其通过Borker其实也就是我们理解的Server来达到一个代理中转的作用，将消息接收并派发给订阅者。  
在转发消息的时候Borker使用Topic来过滤过客端。  
Topic就好比一个具体路径或者节点，客户端会有一个自己需要订阅或者发布的指定路径。也可以理解为Topic就像一个通道，它把发布者与它的订阅者连接起来。话题由MQTT代理管理。通过这个虚拟通道，发布者与订阅者解耦，客户端（发布者或订阅者）不必相互知道。

![markdown](http://rui0.cn/wp-content/uploads/2018/07/pubsub.png "markdow")

目前有许多MQTT消息中间件服务器，比如  
 - Mosquitto  
 - RabbitMQ  
 - Apache ActiveMQ  
 - HiveMQ  
 - EMQ  
 - ……  
 
[Mosquitto](http://mosquitto.org/download/)是一款实现了消息推送协议 MQTT v3.1/v3.1.1 的开源消息代理软件,提供轻量级的,支持可发布/可订阅的的消息推送模式,使设备对设备之间的短消息通信变得简单,比如现在应用广泛的低功耗传感器, 手机、嵌入式计算机、微型控制器等移动设备。  
  
[RabbitMQ](http://www.rabbitmq.com/)是AMQP协议领先的一个实现，它实现了代理(Broker)架构，意味着消息在发送到客户端之前可以在中央节点上排队。此特性使得RabbitMQ易于使用和部署，适宜于很多场景如路由、负载均衡或消息持久化等，用消息队列只需几行代码即可搞定。但是，这使得它的可扩展性差，速度较慢，因为中央节点增加了延迟，消息封装后也比较大。  
  
[ZeroMQ](http://zeromq.org/)是一个非常轻量级的消息系统，专门为高吞吐量/低延迟的场景开发，在金融界的应用中经常可以发现它。与RabbitMQ相比，ZeroMQ支持许多高级消息场景，但是你必须实现ZeroMQ框架中的各个块（比如Socket或Device等）。ZeroMQ非常灵活，但是你必须学习它的80页的手册（如果你要写一个分布式系统，一定要阅读它）。  
  
[Redis](https://redis.io/)是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。  
  
[ActiveMQ](http://activemq.apache.org/)居于两者之间，类似于ZemoMQ，它可以部署于代理模式和P2P模式。类似于RabbitMQ，它易于实现高级场景，而且只需付出低消耗。它被誉为消息中间件的“瑞士军刀”。要注意一点，ActiveMQ的下一代产品为[Apollo](http://activemq.apache.org/apollo/)。  
  
[EMQ X](https://www.emqx.io/cn/) 基于 Erlang/OTP 平台开发的 MQTT 消息服务器，是开源社区中最流行的 MQTT 消息服务器，EMQ X 主要有以下的特点：  
 - 基于 Apache 2.0 协议许可，完全开源。EMQ X 的代码都放在 Github 中，用户可以查看所有源代码。  

 - EMQ X 3.0 支持 MQTT 5.0 协议，是 开源社区中第一个 支持 5.0 协议规范的消息服务器，并且完全兼容 MQTT V3.1 和 V3.1.1 协议。除了 MQTT 协议之外，EMQ X 还支持别的一些物联网协议（具体请参见下文的 EMQ X Broker 产品功能介绍）。  

 - 单机支持百万连接，集群支持千万级连接；毫秒级消息转发。EMQ X 中应用了多种技术以实现上述功能：  
    - 利用 Erlang/OTP 平台的软实时、高并发和容错  
    -  全异步架构  
    - 连接、会话、路由、集群的分层设计  
    - 消息平面和控制平面的分离等  
 - 扩展模块和插件，EMQ X 提供了灵活的扩展机制，可以实现私有协议、认证鉴权、数据持久化、桥接转发和管理控制台等的扩展  

 - 桥接：EMQ X 可以跟别的消息系统进行对接，比如 EMQ X Enterprise 版本中可以支持将消息转发到 Kafka、RabbitMQ 或者别的 EMQ 节点等  

 - 共享订阅：共享订阅支持通过负载均衡的方式在多个订阅者之间来分发 MQTT 消息。比如针对物联网等数据采集场景，会有比较多的设备在发送数据，通过共享订阅的方式可以在订阅端设置多个订阅者来实现这几个订阅者之间的工作负载均衡  

#### 以上来源:  
http://rui0.cn/archives/975  
https://my.oschina.net/yanjava/blog/3000232  
https://docs.emqx.io/docs/tutorial/zh/quick_start/whats_emqx.html  

### 目前的漏洞发现  

#### 身份认证漏洞  
 - 由于物联网云平台仅仅做到了平台层的身份验证（客户端身份验证登陆），没有将协议层的身份ClientId和平台层的身份标识进行绑定，所以攻击者如果已知设备的ClientId，可以向Borker发送CONNECT消息。MQTT协议中规定如果新客户端共享同一ClientId，要求云平台断开现有客户端。所以具有相同ClientID的设备将被踢下线，从而使得用户对其IoT设备失去控制。  
#### 授权操作漏洞  
- 遗嘱消息：  
MQTT 协议规定一旦客户端在没有DISCONNECT消息的情况下意外丢失连接，Broker将向该主题的所有订阅客户端广播在CONNECT消息中的遗嘱消息。所以一旦攻击者获得过用户设备的使用权，可以向Broker发送带有控制设备的遗嘱信息的CONNECT消息。在攻击者失去对设备的常规控制权后，攻击者仍然可以通过遗嘱消息控制设备。  
- 保留消息：
攻击者可以在获得设备的使用权之后向Broker发送定时控制设备的Retained Message。Borker存储某个主题的最后保留消息，订阅此主题的任何客户端都将收到此Retained Message。当受害者用户控制该设备后，设备将订阅该主题并从攻击者接收定时命令。  
  
#### 通配符订阅所有消息  

描述MQTT资源（例如，主题）的语法灵活，如果不仔细处理，则攻击者有极大的机会来过度访问其他人的敏感或隐私关键资源。  
比如说主题的通配符问题：Suning Smart Living的用户都可以订阅该平台的通用 /＃ 主题，这意味着攻击者可以订阅所有的主题从而获得所有用户的隐私信息。  

#### 物联网连接的合法性  
- 在真实应用场景中，一个设备标识往往可以用多个ClientID与云建立多个MQTT连接。当攻击者拥有受害者设备的权利时，他可以构建ScriptDevice和另一个脚本ScriptApp，这些脚本可以使用受害者的应用程序的凭据订阅设备的主题，并使它们保持在线。另一个用户绑定此设备后，ScriptApp仍然会收到用真实设备加密的新用户邮件。  
- 还有另一个漏洞。设备使用的MQTT凭证随着与移动应用程序共享的密钥而变化。当新用户绑定此设备时，设备的先前凭据将过期并被云拒绝，但是ScriptDevice利用MQTT的持久连接功能在凭据过期前经过身份验证后建立的连接仍保持通信。

#### 以上漏洞解决方法  
 - 建立身份联系  
   平台将客户端首次报告的ClientID绑定到其平台标识，并拒绝声明此ClientID的其他客户端。为防止恶意占用，被允许的ClientID可能需要固定的前缀。  
 - 管理连接  
   连接是在 MQTT 中进行身份验证后授予的资源类型，因此只要凭据无效，平台就必须正确撤销连接。不能让此连接进行持续会话。   
 - 面向消息的访问控制模块  
   建立面向消息的使用控制模块，此模块增强了在云上每一条接收和将要发送的消息的限制。  
   
    
 来源：《MQTT-IoT》
 
